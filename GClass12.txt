using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;

// Token: 0x02000011 RID: 17
public class GClass12
{
	// Token: 0x060000E9 RID: 233 RVA: 0x00004284 File Offset: 0x00002484
	public GClass12(string string_1)
	{
		if (GClass12.smethod_0(string_1))
		{
			throw GClass12.smethod_1("masterKey can not be null or empty.");
		}
		Rfc2898DeriveBytes rfc2898DeriveBytes = GClass12.smethod_2(string_1, GClass12.byte_2, 50000);
		try
		{
			this.byte_0 = GClass12.smethod_3(rfc2898DeriveBytes, 32);
			this.byte_1 = GClass12.smethod_3(rfc2898DeriveBytes, 64);
		}
		finally
		{
			if (rfc2898DeriveBytes != null)
			{
				GClass12.smethod_4(rfc2898DeriveBytes);
			}
		}
	}

	// Token: 0x060000EA RID: 234 RVA: 0x0000268D File Offset: 0x0000088D
	public string method_0(string string_1)
	{
		return GClass12.smethod_7(this.method_1(GClass12.smethod_6(GClass12.smethod_5(), string_1)));
	}

	// Token: 0x060000EB RID: 235 RVA: 0x000042F4 File Offset: 0x000024F4
	public byte[] method_1(byte[] byte_3)
	{
		if (byte_3 == null)
		{
			throw GClass12.smethod_8("input can not be null.");
		}
		MemoryStream memoryStream = GClass12.smethod_9();
		byte[] array2;
		try
		{
			GClass12.smethod_10(memoryStream, 32L);
			AesCryptoServiceProvider aesCryptoServiceProvider = GClass12.smethod_11();
			try
			{
				GClass12.smethod_12(aesCryptoServiceProvider, 256);
				GClass12.smethod_13(aesCryptoServiceProvider, 128);
				GClass12.smethod_14(aesCryptoServiceProvider, CipherMode.CBC);
				GClass12.smethod_15(aesCryptoServiceProvider, PaddingMode.PKCS7);
				GClass12.smethod_16(aesCryptoServiceProvider, this.byte_0);
				GClass12.smethod_17(aesCryptoServiceProvider);
				CryptoStream cryptoStream = GClass12.smethod_19(memoryStream, GClass12.smethod_18(aesCryptoServiceProvider), CryptoStreamMode.Write);
				try
				{
					GClass12.smethod_21(memoryStream, GClass12.smethod_20(aesCryptoServiceProvider), 0, GClass12.smethod_20(aesCryptoServiceProvider).Length);
					GClass12.smethod_21(cryptoStream, byte_3, 0, byte_3.Length);
					GClass12.smethod_22(cryptoStream);
					HMACSHA256 hmacsha = GClass12.smethod_23(this.byte_1);
					try
					{
						byte[] array = GClass12.smethod_25(hmacsha, GClass12.smethod_24(memoryStream), 32, GClass12.smethod_24(memoryStream).Length - 32);
						GClass12.smethod_10(memoryStream, 0L);
						GClass12.smethod_21(memoryStream, array, 0, array.Length);
					}
					finally
					{
						if (hmacsha != null)
						{
							GClass12.smethod_4(hmacsha);
						}
					}
				}
				finally
				{
					if (cryptoStream != null)
					{
						GClass12.smethod_4(cryptoStream);
					}
				}
			}
			finally
			{
				if (aesCryptoServiceProvider != null)
				{
					GClass12.smethod_4(aesCryptoServiceProvider);
				}
			}
			array2 = GClass12.smethod_24(memoryStream);
		}
		finally
		{
			if (memoryStream != null)
			{
				GClass12.smethod_4(memoryStream);
			}
		}
		return array2;
	}

	// Token: 0x060000EC RID: 236 RVA: 0x000026A5 File Offset: 0x000008A5
	public string method_2(string string_1)
	{
		return GClass12.smethod_27(GClass12.smethod_5(), this.method_3(GClass12.smethod_26(string_1)));
	}

	// Token: 0x060000ED RID: 237 RVA: 0x00004444 File Offset: 0x00002644
	public byte[] method_3(byte[] byte_3)
	{
		if (byte_3 == null)
		{
			throw GClass12.smethod_8("input can not be null.");
		}
		MemoryStream memoryStream = GClass12.smethod_28(byte_3);
		byte[] array6;
		try
		{
			AesCryptoServiceProvider aesCryptoServiceProvider = GClass12.smethod_11();
			try
			{
				GClass12.smethod_12(aesCryptoServiceProvider, 256);
				GClass12.smethod_13(aesCryptoServiceProvider, 128);
				GClass12.smethod_14(aesCryptoServiceProvider, CipherMode.CBC);
				GClass12.smethod_15(aesCryptoServiceProvider, PaddingMode.PKCS7);
				GClass12.smethod_16(aesCryptoServiceProvider, this.byte_0);
				HMACSHA256 hmacsha = GClass12.smethod_23(this.byte_1);
				try
				{
					byte[] array = GClass12.smethod_25(hmacsha, GClass12.smethod_24(memoryStream), 32, GClass12.smethod_24(memoryStream).Length - 32);
					byte[] array2 = new byte[32];
					GClass12.smethod_29(memoryStream, array2, 0, array2.Length);
					if (!this.method_4(array, array2))
					{
						throw GClass12.smethod_30("Invalid message authentication code (MAC).");
					}
				}
				finally
				{
					if (hmacsha != null)
					{
						GClass12.smethod_4(hmacsha);
					}
				}
				byte[] array3 = new byte[16];
				GClass12.smethod_29(memoryStream, array3, 0, 16);
				GClass12.smethod_31(aesCryptoServiceProvider, array3);
				CryptoStream cryptoStream = GClass12.smethod_19(memoryStream, GClass12.smethod_32(aesCryptoServiceProvider), CryptoStreamMode.Read);
				try
				{
					byte[] array4 = new byte[GClass12.smethod_33(memoryStream) - 16L + 1L];
					byte[] array5 = new byte[GClass12.smethod_29(cryptoStream, array4, 0, array4.Length)];
					GClass12.smethod_34(array4, 0, array5, 0, array5.Length);
					array6 = array5;
				}
				finally
				{
					if (cryptoStream != null)
					{
						GClass12.smethod_4(cryptoStream);
					}
				}
			}
			finally
			{
				if (aesCryptoServiceProvider != null)
				{
					GClass12.smethod_4(aesCryptoServiceProvider);
				}
			}
		}
		finally
		{
			if (memoryStream != null)
			{
				GClass12.smethod_4(memoryStream);
			}
		}
		return array6;
	}

	// Token: 0x060000EE RID: 238 RVA: 0x000045FC File Offset: 0x000027FC
	[MethodImpl(MethodImplOptions.NoOptimization)]
	private bool method_4(byte[] byte_3, byte[] byte_4)
	{
		bool flag = true;
		for (int i = 0; i < byte_3.Length; i++)
		{
			if (byte_3[i] != byte_4[i])
			{
				flag = false;
			}
		}
		return flag;
	}

	// Token: 0x060000EF RID: 239 RVA: 0x000026BD File Offset: 0x000008BD
	// Note: this type is marked as 'beforefieldinit'.
	static GClass12()
	{
		byte[] array = new byte[32];
		GClass12.smethod_35(array, fieldof(Class2.Fld_hRmHOhcN).FieldHandle);
		GClass12.byte_2 = array;
	}

	// Token: 0x060000F0 RID: 240 RVA: 0x000026D6 File Offset: 0x000008D6
	static bool smethod_0(string string_1)
	{
		return string.IsNullOrEmpty(string_1);
	}

	// Token: 0x060000F1 RID: 241 RVA: 0x000026DE File Offset: 0x000008DE
	static ArgumentException smethod_1(string string_1)
	{
		return new ArgumentException(string_1);
	}

	// Token: 0x060000F2 RID: 242 RVA: 0x000026E6 File Offset: 0x000008E6
	static Rfc2898DeriveBytes smethod_2(string string_1, byte[] byte_3, int int_4)
	{
		return new Rfc2898DeriveBytes(string_1, byte_3, int_4);
	}

	// Token: 0x060000F3 RID: 243 RVA: 0x000026F0 File Offset: 0x000008F0
	static byte[] smethod_3(DeriveBytes deriveBytes_0, int int_4)
	{
		return deriveBytes_0.GetBytes(int_4);
	}

	// Token: 0x060000F4 RID: 244 RVA: 0x00002276 File Offset: 0x00000476
	static void smethod_4(IDisposable idisposable_0)
	{
		idisposable_0.Dispose();
	}

	// Token: 0x060000F5 RID: 245 RVA: 0x000020FE File Offset: 0x000002FE
	static Encoding smethod_5()
	{
		return Encoding.UTF8;
	}

	// Token: 0x060000F6 RID: 246 RVA: 0x0000212E File Offset: 0x0000032E
	static byte[] smethod_6(Encoding encoding_0, string string_1)
	{
		return encoding_0.GetBytes(string_1);
	}

	// Token: 0x060000F7 RID: 247 RVA: 0x00002456 File Offset: 0x00000656
	static string smethod_7(byte[] byte_3)
	{
		return Convert.ToBase64String(byte_3);
	}

	// Token: 0x060000F8 RID: 248 RVA: 0x000026F9 File Offset: 0x000008F9
	static ArgumentNullException smethod_8(string string_1)
	{
		return new ArgumentNullException(string_1);
	}

	// Token: 0x060000F9 RID: 249 RVA: 0x00002701 File Offset: 0x00000901
	static MemoryStream smethod_9()
	{
		return new MemoryStream();
	}

	// Token: 0x060000FA RID: 250 RVA: 0x00002708 File Offset: 0x00000908
	static void smethod_10(Stream stream_0, long long_0)
	{
		stream_0.Position = long_0;
	}

	// Token: 0x060000FB RID: 251 RVA: 0x00002711 File Offset: 0x00000911
	static AesCryptoServiceProvider smethod_11()
	{
		return new AesCryptoServiceProvider();
	}

	// Token: 0x060000FC RID: 252 RVA: 0x00002718 File Offset: 0x00000918
	static void smethod_12(SymmetricAlgorithm symmetricAlgorithm_0, int int_4)
	{
		symmetricAlgorithm_0.KeySize = int_4;
	}

	// Token: 0x060000FD RID: 253 RVA: 0x00002721 File Offset: 0x00000921
	static void smethod_13(SymmetricAlgorithm symmetricAlgorithm_0, int int_4)
	{
		symmetricAlgorithm_0.BlockSize = int_4;
	}

	// Token: 0x060000FE RID: 254 RVA: 0x0000272A File Offset: 0x0000092A
	static void smethod_14(SymmetricAlgorithm symmetricAlgorithm_0, CipherMode cipherMode_0)
	{
		symmetricAlgorithm_0.Mode = cipherMode_0;
	}

	// Token: 0x060000FF RID: 255 RVA: 0x00002733 File Offset: 0x00000933
	static void smethod_15(SymmetricAlgorithm symmetricAlgorithm_0, PaddingMode paddingMode_0)
	{
		symmetricAlgorithm_0.Padding = paddingMode_0;
	}

	// Token: 0x06000100 RID: 256 RVA: 0x0000273C File Offset: 0x0000093C
	static void smethod_16(SymmetricAlgorithm symmetricAlgorithm_0, byte[] byte_3)
	{
		symmetricAlgorithm_0.Key = byte_3;
	}

	// Token: 0x06000101 RID: 257 RVA: 0x00002745 File Offset: 0x00000945
	static void smethod_17(SymmetricAlgorithm symmetricAlgorithm_0)
	{
		symmetricAlgorithm_0.GenerateIV();
	}

	// Token: 0x06000102 RID: 258 RVA: 0x0000274D File Offset: 0x0000094D
	static ICryptoTransform smethod_18(SymmetricAlgorithm symmetricAlgorithm_0)
	{
		return symmetricAlgorithm_0.CreateEncryptor();
	}

	// Token: 0x06000103 RID: 259 RVA: 0x00002755 File Offset: 0x00000955
	static CryptoStream smethod_19(Stream stream_0, ICryptoTransform icryptoTransform_0, CryptoStreamMode cryptoStreamMode_0)
	{
		return new CryptoStream(stream_0, icryptoTransform_0, cryptoStreamMode_0);
	}

	// Token: 0x06000104 RID: 260 RVA: 0x0000275F File Offset: 0x0000095F
	static byte[] smethod_20(SymmetricAlgorithm symmetricAlgorithm_0)
	{
		return symmetricAlgorithm_0.IV;
	}

	// Token: 0x06000105 RID: 261 RVA: 0x0000235F File Offset: 0x0000055F
	static void smethod_21(Stream stream_0, byte[] byte_3, int int_4, int int_5)
	{
		stream_0.Write(byte_3, int_4, int_5);
	}

	// Token: 0x06000106 RID: 262 RVA: 0x00002767 File Offset: 0x00000967
	static void smethod_22(CryptoStream cryptoStream_0)
	{
		cryptoStream_0.FlushFinalBlock();
	}

	// Token: 0x06000107 RID: 263 RVA: 0x0000276F File Offset: 0x0000096F
	static HMACSHA256 smethod_23(byte[] byte_3)
	{
		return new HMACSHA256(byte_3);
	}

	// Token: 0x06000108 RID: 264 RVA: 0x00002777 File Offset: 0x00000977
	static byte[] smethod_24(MemoryStream memoryStream_0)
	{
		return memoryStream_0.ToArray();
	}

	// Token: 0x06000109 RID: 265 RVA: 0x0000277F File Offset: 0x0000097F
	static byte[] smethod_25(HashAlgorithm hashAlgorithm_0, byte[] byte_3, int int_4, int int_5)
	{
		return hashAlgorithm_0.ComputeHash(byte_3, int_4, int_5);
	}

	// Token: 0x0600010A RID: 266 RVA: 0x00002105 File Offset: 0x00000305
	static byte[] smethod_26(string string_1)
	{
		return Convert.FromBase64String(string_1);
	}

	// Token: 0x0600010B RID: 267 RVA: 0x0000210D File Offset: 0x0000030D
	static string smethod_27(Encoding encoding_0, byte[] byte_3)
	{
		return encoding_0.GetString(byte_3);
	}

	// Token: 0x0600010C RID: 268 RVA: 0x0000236A File Offset: 0x0000056A
	static MemoryStream smethod_28(byte[] byte_3)
	{
		return new MemoryStream(byte_3);
	}

	// Token: 0x0600010D RID: 269 RVA: 0x00002330 File Offset: 0x00000530
	static int smethod_29(Stream stream_0, byte[] byte_3, int int_4, int int_5)
	{
		return stream_0.Read(byte_3, int_4, int_5);
	}

	// Token: 0x0600010E RID: 270 RVA: 0x0000278A File Offset: 0x0000098A
	static CryptographicException smethod_30(string string_1)
	{
		return new CryptographicException(string_1);
	}

	// Token: 0x0600010F RID: 271 RVA: 0x00002792 File Offset: 0x00000992
	static void smethod_31(SymmetricAlgorithm symmetricAlgorithm_0, byte[] byte_3)
	{
		symmetricAlgorithm_0.IV = byte_3;
	}

	// Token: 0x06000110 RID: 272 RVA: 0x0000279B File Offset: 0x0000099B
	static ICryptoTransform smethod_32(SymmetricAlgorithm symmetricAlgorithm_0)
	{
		return symmetricAlgorithm_0.CreateDecryptor();
	}

	// Token: 0x06000111 RID: 273 RVA: 0x000027A3 File Offset: 0x000009A3
	static long smethod_33(Stream stream_0)
	{
		return stream_0.Length;
	}

	// Token: 0x06000112 RID: 274 RVA: 0x000027AB File Offset: 0x000009AB
	static void smethod_34(Array array_0, int int_4, Array array_1, int int_5, int int_6)
	{
		Buffer.BlockCopy(array_0, int_4, array_1, int_5, int_6);
	}

	// Token: 0x06000113 RID: 275 RVA: 0x000027B8 File Offset: 0x000009B8
	static void smethod_35(Array array_0, RuntimeFieldHandle runtimeFieldHandle_0)
	{
		RuntimeHelpers.InitializeArray(array_0, runtimeFieldHandle_0);
	}

	// Token: 0x04000039 RID: 57
	private const int int_0 = 32;

	// Token: 0x0400003A RID: 58
	private const int int_1 = 64;

	// Token: 0x0400003B RID: 59
	private const int int_2 = 16;

	// Token: 0x0400003C RID: 60
	private const int int_3 = 32;

	// Token: 0x0400003D RID: 61
	private readonly byte[] byte_0;

	// Token: 0x0400003E RID: 62
	private readonly byte[] byte_1;

	// Token: 0x0400003F RID: 63
	private static readonly byte[] byte_2;

	// Token: 0x04000040 RID: 64
	public static string string_0;
}
